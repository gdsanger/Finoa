import logging
from datetime import timedelta

from django.shortcuts import render, get_object_or_404, redirect
from django.http import JsonResponse, Http404
from django.views.decorators.http import require_http_methods
from django.contrib.auth.decorators import login_required
from django.core.paginator import Paginator
from django.core.exceptions import ImproperlyConfigured
from django.utils import timezone

from .models import Signal, Trade, WorkerStatus, TradingAsset, AssetDiagnostics, AssetPriceStatus
from .services.chart_service import (
    get_asset_by_symbol,
    get_candles_for_asset,
    get_breakout_context_for_asset,
    get_session_ranges_for_asset,
    SUPPORTED_TIME_WINDOWS,
)

from core.services.broker import BrokerRegistry, BrokerError, AuthenticationError

logger = logging.getLogger(__name__)

# Diagnostics time window constants
DIAGNOSTICS_MIN_WINDOW_MINUTES = 1
DIAGNOSTICS_MAX_WINDOW_MINUTES = 1440  # 24 hours
DIAGNOSTICS_DEFAULT_WINDOW_MINUTES = 60


def _parse_window_minutes(window_str: str) -> int:
    """
    Parse and validate window minutes from request parameter.
    
    Args:
        window_str: String value from request GET parameter
        
    Returns:
        Validated window minutes within allowed bounds
    """
    try:
        window_minutes = int(window_str)
    except ValueError:
        window_minutes = DIAGNOSTICS_DEFAULT_WINDOW_MINUTES
    
    # Clamp to valid range
    if window_minutes < DIAGNOSTICS_MIN_WINDOW_MINUTES:
        window_minutes = DIAGNOSTICS_MIN_WINDOW_MINUTES
    elif window_minutes > DIAGNOSTICS_MAX_WINDOW_MINUTES:
        window_minutes = DIAGNOSTICS_MAX_WINDOW_MINUTES
    
    return window_minutes


@login_required
def signal_dashboard(request):
    """
    Signal Dashboard - Main view showing all active trading signals.
    
    Displays signals from the database that are generated by the real
    Strategy Engine, KI Layer, and Risk Engine services.
    """
    signals = Signal.objects.filter(status='ACTIVE')
    active_count = signals.count()
    
    # Get active trading assets for the asset selector in the Breakout Range Diagnose card
    active_assets = TradingAsset.objects.filter(is_active=True).order_by('name')
    
    context = {
        'signals': signals,
        'active_count': active_count,
        'active_assets': active_assets,
    }
    
    return render(request, 'trading/signal_dashboard.html', context)


@login_required
def signal_detail(request, signal_id):
    """
    Trade Detail Panel - Detailed view of a specific signal.
    
    Displays full signal details including KI evaluation and Risk Engine results.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
    except (Signal.DoesNotExist, ValueError):
        # Signal not found - redirect to dashboard
        return redirect('signal_dashboard')
    
    context = {
        'signal': signal,
    }
    
    return render(request, 'trading/signal_detail.html', context)


@login_required
@require_http_methods(['POST'])
def execute_live_trade(request, signal_id):
    """
    Execute a live trade for a signal.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        
        if not signal.can_execute_live:
            return JsonResponse({
                'success': False,
                'error': 'Live Trade nicht erlaubt basierend auf Risk Engine Status.'
            }, status=400)
        
        # Create the trade
        trade = Trade.objects.create(
            signal=signal,
            trade_type='LIVE',
            entry_price=signal.trigger_price,
            stop_loss=signal.gpt_corrected_sl or signal.stop_loss,
            take_profit=signal.gpt_corrected_tp or signal.take_profit,
            position_size=signal.gpt_corrected_size or signal.position_size,
        )
        
        # Update signal status
        signal.status = 'EXECUTED'
        signal.executed_at = timezone.now()
        signal.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Live Trade erfolgreich ausgeführt!',
            'trade_id': str(trade.id)
        })
        
    except Signal.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Signal nicht gefunden.'
        }, status=404)


@login_required
@require_http_methods(['POST'])
def execute_shadow_trade(request, signal_id):
    """
    Execute a shadow trade for a signal.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        
        # Create the shadow trade
        trade = Trade.objects.create(
            signal=signal,
            trade_type='SHADOW',
            entry_price=signal.trigger_price,
            stop_loss=signal.gpt_corrected_sl or signal.stop_loss,
            take_profit=signal.gpt_corrected_tp or signal.take_profit,
            position_size=signal.gpt_corrected_size or signal.position_size,
        )
        
        # Update signal status
        signal.status = 'SHADOW'
        signal.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Shadow Trade erfolgreich gestartet!',
            'trade_id': str(trade.id)
        })
        
    except Signal.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Signal nicht gefunden.'
        }, status=404)


@login_required
@require_http_methods(['POST'])
def reject_signal(request, signal_id):
    """
    Reject/dismiss a signal.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        signal.status = 'REJECTED'
        signal.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Signal verworfen.'
        })
        
    except Signal.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Signal nicht gefunden.'
        }, status=404)


@login_required
def trade_history(request):
    """
    Trade history view - Shows executed and shadow trades with pagination.
    """
    trade_list = Trade.objects.select_related('signal').all()
    
    # Paginate results
    paginator = Paginator(trade_list, 25)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'trades': page_obj,
        'page_obj': page_obj,
    }
    
    return render(request, 'trading/trade_history.html', context)


# API Endpoints for HTMX/AJAX integration

@login_required
def api_signals(request):
    """
    GET /api/signals - Return list of active signals as JSON.
    """
    signals = list(Signal.objects.filter(status='ACTIVE').values())
    return JsonResponse({'signals': signals})


@login_required
def api_signals_since(request, since):
    """
    GET /api/signals/since/{timestamp} - Return new signals created after the given timestamp.
    
    Args:
        since: ISO 8601 timestamp string (e.g., '2025-01-01T12:00:00Z')
    
    Response:
        {
            "now": "2025-01-01T12:05:00Z",  # Current server time
            "count": 2,                      # Number of new signals
            "signals": [...]                 # List of new signals
        }
    """
    from django.utils.dateparse import parse_datetime
    
    # Parse the since timestamp
    since_dt = parse_datetime(since)
    if since_dt is None:
        return JsonResponse({
            'error': 'Invalid timestamp format. Use ISO 8601 format (e.g., 2025-01-01T12:00:00Z).'
        }, status=400)
    
    # Ensure the datetime is timezone-aware
    if since_dt.tzinfo is None:
        since_dt = timezone.make_aware(since_dt, timezone.utc)
    
    # Get current server time
    now = timezone.now()
    
    # Query for signals created after the since timestamp
    new_signals = Signal.objects.filter(
        created_at__gt=since_dt,
        status='ACTIVE'
    ).order_by('-created_at')
    
    # Serialize signals
    signals_data = []
    for signal in new_signals:
        signals_data.append({
            'id': str(signal.id),
            'setup_type': signal.setup_type,
            'setup_type_display': signal.get_setup_type_display(),
            'session_phase': signal.session_phase,
            'session_phase_display': signal.get_session_phase_display(),
            'instrument': signal.instrument,
            'direction': signal.direction,
            'trigger_price': str(signal.trigger_price) if signal.trigger_price else None,
            'range_high': str(signal.range_high) if signal.range_high else None,
            'range_low': str(signal.range_low) if signal.range_low else None,
            'stop_loss': str(signal.stop_loss) if signal.stop_loss else None,
            'take_profit': str(signal.take_profit) if signal.take_profit else None,
            'position_size': str(signal.position_size) if signal.position_size else None,
            'gpt_confidence': str(signal.gpt_confidence),
            'risk_status': signal.risk_status,
            'status': signal.status,
            'created_at': signal.created_at.isoformat(),
        })
    
    return JsonResponse({
        'now': now.isoformat(),
        'count': len(signals_data),
        'signals': signals_data,
    })


@login_required
def api_signal_detail(request, signal_id):
    """
    GET /api/trade/{id} - Return signal details as JSON.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        data = {
            'id': str(signal.id),
            'setup_type': signal.setup_type,
            'session_phase': signal.session_phase,
            'direction': signal.direction,
            'trigger_price': str(signal.trigger_price),
            'range_high': str(signal.range_high),
            'range_low': str(signal.range_low),
            'stop_loss': str(signal.stop_loss),
            'take_profit': str(signal.take_profit),
            'position_size': str(signal.position_size),
            'ki_reasoning': signal.ki_reasoning,
            'gpt_confidence': str(signal.gpt_confidence),
            'gpt_reasoning': signal.gpt_reasoning,
            'risk_status': signal.risk_status,
            'risk_reasoning': signal.risk_reasoning,
            'status': signal.status,
            'can_execute_live': signal.can_execute_live,
        }
        return JsonResponse(data)
    except Signal.DoesNotExist:
        return JsonResponse({'error': 'Signal nicht gefunden.'}, status=404)


@login_required
def api_account_state(request):
    """
    GET /api/account-state - Return current account state (balance, margin) from IG Broker.
    
    Returns JSON with account information including:
    - balance: Current account balance
    - available: Available funds for trading
    - equity: Total equity including open positions
    - margin_used: Margin currently in use
    - margin_available: Available margin
    - unrealized_pnl: Unrealized profit/loss
    - currency: Account currency
    - account_name: Account name
    - account_id: Account ID
    - timestamp: When the data was fetched
    - connected: Whether the broker is connected
    """
    try:
        # Use BrokerRegistry to get the IG broker (default for account state view)
        registry = BrokerRegistry()
        broker = registry.get_ig_broker()
        
        try:
            # Get account state
            account_state = broker.get_account_state()
            
            return JsonResponse({
                'success': True,
                'data': {
                    'account_id': account_state.account_id,
                    'account_name': account_state.account_name,
                    'balance': str(account_state.balance),
                    'available': str(account_state.available),
                    'equity': str(account_state.equity),
                    'margin_used': str(account_state.margin_used),
                    'margin_available': str(account_state.margin_available),
                    'unrealized_pnl': str(account_state.unrealized_pnl),
                    'currency': account_state.currency,
                    'timestamp': account_state.timestamp.isoformat() if account_state.timestamp else None,
                },
                'connected': True,
            })
        finally:
            # Clean up registry connections
            registry.disconnect_all()
            
    except ImproperlyConfigured as e:
        logger.warning(f"IG Broker not configured: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Broker nicht konfiguriert. Bitte IG Broker im Admin-Bereich konfigurieren.',
            'connected': False,
        }, status=503)
    except AuthenticationError as e:
        logger.error(f"IG Broker authentication failed: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Broker-Authentifizierung fehlgeschlagen.',
            'connected': False,
        }, status=401)
    except (BrokerError, ConnectionError) as e:
        logger.error(f"IG Broker error: {e}")
        return JsonResponse({
            'success': False,
            'error': f'Broker-Fehler: {str(e)}',
            'connected': False,
        }, status=503)
    except Exception as e:
        logger.error(f"Unexpected error fetching account state: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Ein unerwarteter Fehler ist aufgetreten.',
            'connected': False,
        }, status=500)


@login_required
def api_all_brokers_account_state(request):
    """
    GET /api/all-brokers-account-state - Return account state from all configured brokers.
    
    Returns JSON with account information for both IG and MEXC brokers:
    - ig: IG broker account state (if configured and connected)
    - mexc: MEXC broker account state (if configured and connected)
    
    Each broker section contains:
    - connected: Whether the broker is connected
    - data: Account state data (if connected)
    - error: Error message (if not connected)
    """
    result = {
        'success': True,
        'ig': {
            'connected': False,
            'data': None,
            'error': None,
        },
        'mexc': {
            'connected': False,
            'data': None,
            'error': None,
        },
    }
    
    registry = BrokerRegistry()
    
    # Try to get IG account state
    try:
        ig_broker = registry.get_ig_broker()
        ig_account_state = ig_broker.get_account_state()
        result['ig'] = {
            'connected': True,
            'data': {
                'account_id': ig_account_state.account_id,
                'account_name': ig_account_state.account_name,
                'balance': str(ig_account_state.balance),
                'available': str(ig_account_state.available),
                'equity': str(ig_account_state.equity),
                'margin_used': str(ig_account_state.margin_used),
                'margin_available': str(ig_account_state.margin_available),
                'unrealized_pnl': str(ig_account_state.unrealized_pnl),
                'currency': ig_account_state.currency,
                'timestamp': ig_account_state.timestamp.isoformat() if ig_account_state.timestamp else None,
            },
            'error': None,
        }
    except ImproperlyConfigured as e:
        logger.warning(f"IG Broker not configured: {e}")
        result['ig']['error'] = 'Nicht konfiguriert'
    except AuthenticationError as e:
        logger.error(f"IG Broker authentication failed: {e}")
        result['ig']['error'] = 'Authentifizierung fehlgeschlagen'
    except (BrokerError, ConnectionError) as e:
        logger.error(f"IG Broker error: {e}")
        result['ig']['error'] = f'Verbindungsfehler: {str(e)}'
    except Exception as e:
        logger.error(f"Unexpected error fetching IG account state: {e}")
        result['ig']['error'] = 'Unbekannter Fehler'
    
    # Try to get MEXC account state
    try:
        mexc_broker = registry.get_mexc_broker()
        mexc_account_state = mexc_broker.get_account_state()
        result['mexc'] = {
            'connected': True,
            'data': {
                'account_id': mexc_account_state.account_id,
                'account_name': mexc_account_state.account_name,
                'balance': str(mexc_account_state.balance),
                'available': str(mexc_account_state.available),
                'equity': str(mexc_account_state.equity),
                'margin_used': str(mexc_account_state.margin_used),
                'margin_available': str(mexc_account_state.margin_available),
                'unrealized_pnl': str(mexc_account_state.unrealized_pnl),
                'currency': mexc_account_state.currency,
                'timestamp': mexc_account_state.timestamp.isoformat() if mexc_account_state.timestamp else None,
            },
            'error': None,
        }
    except ImproperlyConfigured as e:
        logger.warning(f"MEXC Broker not configured: {e}")
        result['mexc']['error'] = 'Nicht konfiguriert'
    except AuthenticationError as e:
        logger.error(f"MEXC Broker authentication failed: {e}")
        result['mexc']['error'] = 'Authentifizierung fehlgeschlagen'
    except (BrokerError, ConnectionError) as e:
        logger.error(f"MEXC Broker error: {e}")
        result['mexc']['error'] = f'Verbindungsfehler: {str(e)}'
    except Exception as e:
        logger.error(f"Unexpected error fetching MEXC account state: {e}")
        result['mexc']['error'] = 'Unbekannter Fehler'
    
    # Clean up registry connections
    try:
        registry.disconnect_all()
    except Exception as e:
        logger.warning(f"Error disconnecting brokers: {e}")
    
    return JsonResponse(result)


@login_required
def api_worker_status(request):
    """
    GET /fiona/api/worker/status/ - Return current worker status.
    
    Returns JSON with worker status information including:
    - worker_status: ONLINE or OFFLINE (based on last_run_at threshold)
    - last_run_at: Timestamp of last worker loop
    - phase: Current session phase
    - epic: Current instrument being monitored
    - price_info: Bid/Ask/Spread
    - setup_count: Number of setups found in last run
    - diagnostic_message: Human-readable status message
    - diagnostic_criteria: List of criteria with pass/fail status
    - worker_interval: Expected worker loop interval
    - seconds_until_next_run: Countdown to next worker run
    """
    try:
        # Get the current worker status
        status = WorkerStatus.get_current()
        
        if status is None:
            return JsonResponse({
                'success': True,
                'worker_status': 'NO_DATA',
                'status_message': 'Noch keine Worker-Statusdaten vorhanden',
                'data': None,
            })
        
        # Determine if worker is ONLINE or OFFLINE
        # ONLINE if last heartbeat is within 2 * worker_interval
        now = timezone.now()
        threshold_seconds = status.worker_interval * 2
        time_since_last_run = (now - status.last_run_at).total_seconds()
        
        if time_since_last_run <= threshold_seconds:
            worker_status = 'ONLINE'
            status_message = 'Worker ist aktiv'
        else:
            worker_status = 'OFFLINE'
            status_message = f'Worker ist seit {int(time_since_last_run)}s inaktiv'
        
        # Calculate seconds until next run
        seconds_until_next_run = max(0, status.worker_interval - int(time_since_last_run))
        
        # Build response data
        data = {
            'last_run_at': status.last_run_at.isoformat(),
            'phase': status.phase,
            'epic': status.epic,
            'price_info': {
                'bid': str(status.bid_price) if status.bid_price else None,
                'ask': str(status.ask_price) if status.ask_price else None,
                'spread': str(status.spread) if status.spread else None,
            },
            'setup_count': status.setup_count,
            'diagnostic_message': status.diagnostic_message,
            'diagnostic_criteria': status.diagnostic_criteria or [],
            'worker_interval': status.worker_interval,
            'seconds_since_last_run': int(time_since_last_run),
            'seconds_until_next_run': seconds_until_next_run,
        }
        
        return JsonResponse({
            'success': True,
            'worker_status': worker_status,
            'status_message': status_message,
            'data': data,
        })
        
    except Exception as e:
        logger.error(f"Error fetching worker status: {e}")
        return JsonResponse({
            'success': False,
            'worker_status': 'ERROR',
            'status_message': f'Fehler: {str(e)}',
            'data': None,
        }, status=500)


# ============================================================================
# Asset Management Views
# ============================================================================

def _get_asset_form_context(asset=None):
    """
    Get common context for asset create/edit forms.
    
    Args:
        asset: TradingAsset instance or None for create form.
        
    Returns:
        dict: Context dictionary with categories, strategy_types, broker_kinds.
    """
    from .models import TradingAsset
    return {
        'asset': asset,
        'categories': TradingAsset.ASSET_CATEGORIES,
        'strategy_types': TradingAsset.STRATEGY_TYPES,
        'broker_kinds': TradingAsset.BrokerKind.choices,
    }


def _parse_asset_form_data(request):
    """
    Parse asset form data from POST request.
    
    Returns:
        dict: Parsed form data with all asset fields.
    """
    from .models import TradingAsset
    
    # Basic fields
    name = request.POST.get('name', '').strip()
    symbol = request.POST.get('symbol', '').strip()
    epic = request.POST.get('epic', '').strip()
    category = request.POST.get('category', 'commodity')
    tick_size_str = request.POST.get('tick_size', '0.01')
    is_active = request.POST.get('is_active') == 'on'
    
    # Broker configuration
    broker = request.POST.get('broker', 'IG')
    broker_symbol = request.POST.get('broker_symbol', '').strip()
    quote_currency = request.POST.get('quote_currency', 'USD').strip() or 'USD'
    
    # Validate broker value
    valid_brokers = [choice[0] for choice in TradingAsset.BrokerKind.choices]
    if broker not in valid_brokers:
        broker = 'IG'
    
    return {
        'name': name,
        'symbol': symbol,
        'epic': epic,
        'category': category,
        'tick_size_str': tick_size_str,
        'is_active': is_active,
        'broker': broker,
        'broker_symbol': broker_symbol,
        'quote_currency': quote_currency,
    }


@login_required
def asset_list(request):
    """
    List all trading assets with their status and configuration summary.
    """
    from .models import TradingAsset
    
    assets = TradingAsset.objects.all().prefetch_related('breakout_config', 'event_configs')
    
    # Count active vs inactive
    active_count = assets.filter(is_active=True).count()
    inactive_count = assets.filter(is_active=False).count()
    
    # Group by category for display
    categories = {}
    for asset in assets:
        cat = asset.get_category_display()
        if cat not in categories:
            categories[cat] = []
        categories[cat].append(asset)
    
    context = {
        'assets': assets,
        'categories': categories,
        'active_count': active_count,
        'inactive_count': inactive_count,
    }
    
    return render(request, 'trading/asset_list.html', context)


@login_required
def asset_detail(request, asset_id):
    """
    View/Edit details for a specific trading asset.
    """
    from .models import TradingAsset, AssetBreakoutConfig, AssetEventConfig
    from django.contrib import messages
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    
    # Get or create breakout config
    try:
        breakout_config = asset.breakout_config
    except AssetBreakoutConfig.DoesNotExist:
        breakout_config = None
    
    # Get event configs
    event_configs = asset.event_configs.all().order_by('phase')
    
    context = {
        'asset': asset,
        'breakout_config': breakout_config,
        'event_configs': event_configs,
        'session_phases': AssetEventConfig.SESSION_PHASES,
        'event_types': AssetEventConfig.EVENT_TYPES,
    }
    
    return render(request, 'trading/asset_detail.html', context)


@login_required
def asset_create(request):
    """
    Create a new trading asset.
    """
    from .models import TradingAsset, AssetBreakoutConfig
    from django.contrib import messages
    from decimal import Decimal, InvalidOperation
    
    if request.method == 'POST':
        # Parse form data using helper
        form_data = _parse_asset_form_data(request)
        
        # Validate required fields
        if not form_data['name'] or not form_data['symbol'] or not form_data['epic']:
            messages.error(request, 'Name, Symbol und EPIC sind Pflichtfelder.')
            return render(request, 'trading/asset_form.html', _get_asset_form_context())
        
        # Check for duplicate epic
        if TradingAsset.objects.filter(epic=form_data['epic']).exists():
            messages.error(request, f'Ein Asset mit EPIC "{form_data["epic"]}" existiert bereits.')
            return render(request, 'trading/asset_form.html', _get_asset_form_context())
        
        try:
            tick_size = Decimal(form_data['tick_size_str'])
        except InvalidOperation:
            messages.error(request, 'Ungültiger Tick Size Wert.')
            return render(request, 'trading/asset_form.html', _get_asset_form_context())
        
        # Create asset
        asset = TradingAsset.objects.create(
            name=form_data['name'],
            symbol=form_data['symbol'],
            epic=form_data['epic'],
            category=form_data['category'],
            tick_size=tick_size,
            is_active=form_data['is_active'],
            broker=form_data['broker'],
            broker_symbol=form_data['broker_symbol'],
            quote_currency=form_data['quote_currency'],
        )
        
        # Create default breakout config
        AssetBreakoutConfig.objects.create(asset=asset)
        
        messages.success(request, f'Asset "{form_data["name"]}" erfolgreich erstellt.')
        return redirect('asset_detail', asset_id=asset.id)
    
    return render(request, 'trading/asset_form.html', _get_asset_form_context())


@login_required
def asset_edit(request, asset_id):
    """
    Edit an existing trading asset.
    """
    from .models import TradingAsset, AssetBreakoutConfig
    from django.contrib import messages
    from decimal import Decimal, InvalidOperation
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    
    if request.method == 'POST':
        # Parse form data using helper
        form_data = _parse_asset_form_data(request)
        
        # Validate required fields
        if not form_data['name'] or not form_data['symbol'] or not form_data['epic']:
            messages.error(request, 'Name, Symbol und EPIC sind Pflichtfelder.')
            return render(request, 'trading/asset_form.html', _get_asset_form_context(asset))
        
        # Check for duplicate epic (excluding current asset)
        if TradingAsset.objects.filter(epic=form_data['epic']).exclude(id=asset.id).exists():
            messages.error(request, f'Ein anderes Asset mit EPIC "{form_data["epic"]}" existiert bereits.')
            return render(request, 'trading/asset_form.html', _get_asset_form_context(asset))
        
        try:
            tick_size = Decimal(form_data['tick_size_str'])
        except InvalidOperation:
            messages.error(request, 'Ungültiger Tick Size Wert.')
            return render(request, 'trading/asset_form.html', _get_asset_form_context(asset))
        
        # Update asset
        asset.name = form_data['name']
        asset.symbol = form_data['symbol']
        asset.epic = form_data['epic']
        asset.category = form_data['category']
        asset.tick_size = tick_size
        asset.is_active = form_data['is_active']
        asset.broker = form_data['broker']
        asset.broker_symbol = form_data['broker_symbol']
        asset.quote_currency = form_data['quote_currency']
        asset.save()
        
        messages.success(request, f'Asset "{form_data["name"]}" erfolgreich aktualisiert.')
        return redirect('asset_detail', asset_id=asset.id)
    
    return render(request, 'trading/asset_form.html', _get_asset_form_context(asset))


@login_required
@require_http_methods(['POST'])
def asset_toggle_active(request, asset_id):
    """
    Toggle the active status of an asset via HTMX/AJAX.
    """
    from .models import TradingAsset
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    asset.is_active = not asset.is_active
    asset.save()
    
    return JsonResponse({
        'success': True,
        'is_active': asset.is_active,
        'message': f'Asset "{asset.name}" ist jetzt {"aktiv" if asset.is_active else "inaktiv"}.',
    })


@login_required
def breakout_config_edit(request, asset_id):
    """
    Edit breakout configuration for an asset.
    """
    from .models import TradingAsset, AssetBreakoutConfig
    from django.contrib import messages
    from decimal import Decimal, InvalidOperation
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    
    # Get or create breakout config
    breakout_config, created = AssetBreakoutConfig.objects.get_or_create(asset=asset)
    
    if request.method == 'POST':
        try:
            # Helper function to parse optional decimal fields
            def parse_decimal(value, default=None):
                if value and value.strip():
                    return Decimal(value.strip())
                return default
            
            # Helper function to parse optional int fields
            def parse_int(value, default=None):
                if value and value.strip():
                    return int(value.strip())
                return default
            
            # =========================================================
            # Asia Range settings
            # =========================================================
            breakout_config.asia_range_start = request.POST.get('asia_range_start', '00:00')
            breakout_config.asia_range_end = request.POST.get('asia_range_end', '08:00')
            breakout_config.asia_min_range_ticks = int(request.POST.get('asia_min_range_ticks', 10))
            breakout_config.asia_max_range_ticks = int(request.POST.get('asia_max_range_ticks', 200))
            
            # =========================================================
            # London Core settings (NEW)
            # =========================================================
            breakout_config.london_range_start = request.POST.get('london_range_start', '08:00')
            breakout_config.london_range_end = request.POST.get('london_range_end', '12:00')
            breakout_config.london_min_range_ticks = int(request.POST.get('london_min_range_ticks', 10))
            breakout_config.london_max_range_ticks = int(request.POST.get('london_max_range_ticks', 200))
            
            # =========================================================
            # US Core settings
            # =========================================================
            breakout_config.pre_us_start = request.POST.get('pre_us_start', '13:00')
            breakout_config.pre_us_end = request.POST.get('pre_us_end', '15:00')
            breakout_config.us_min_range_ticks = int(request.POST.get('us_min_range_ticks', 10))
            breakout_config.us_max_range_ticks = int(request.POST.get('us_max_range_ticks', 200))
            
            # =========================================================
            # US Core Trading settings (NEW)
            # =========================================================
            breakout_config.us_core_trading_start = request.POST.get('us_core_trading_start', '15:00')
            breakout_config.us_core_trading_end = request.POST.get('us_core_trading_end', '22:00')
            breakout_config.us_core_trading_enabled = request.POST.get('us_core_trading_enabled') == 'on'
            
            # =========================================================
            # EIA Pre/Post settings (NEW)
            # =========================================================
            breakout_config.eia_min_body_fraction = parse_decimal(
                request.POST.get('eia_min_body_fraction'), Decimal('0.60'))
            breakout_config.eia_min_impulse_atr = parse_decimal(
                request.POST.get('eia_min_impulse_atr'))
            breakout_config.eia_impulse_range_high = parse_decimal(
                request.POST.get('eia_impulse_range_high'))
            breakout_config.eia_impulse_range_low = parse_decimal(
                request.POST.get('eia_impulse_range_low'))
            breakout_config.eia_required_impulse_strength = parse_decimal(
                request.POST.get('eia_required_impulse_strength'), Decimal('0.50'))
            breakout_config.eia_reversion_window_min_sec = parse_int(
                request.POST.get('eia_reversion_window_min_sec'), 30)
            breakout_config.eia_reversion_window_max_sec = parse_int(
                request.POST.get('eia_reversion_window_max_sec'), 300)
            breakout_config.eia_max_impulse_duration_min = parse_int(
                request.POST.get('eia_max_impulse_duration_min'), 5)
            
            # =========================================================
            # Breakout requirements
            # =========================================================
            breakout_config.min_breakout_body_fraction = parse_decimal(
                request.POST.get('min_breakout_body_fraction'), Decimal('0.50'))
            breakout_config.max_breakout_body_fraction = parse_decimal(
                request.POST.get('max_breakout_body_fraction'))
            breakout_config.min_breakout_distance_ticks = parse_int(
                request.POST.get('min_breakout_distance_ticks'), 1)
            
            # =========================================================
            # Candle Quality filters (NEW)
            # =========================================================
            breakout_config.min_wick_ratio = parse_decimal(
                request.POST.get('min_wick_ratio'))
            breakout_config.max_wick_ratio = parse_decimal(
                request.POST.get('max_wick_ratio'))
            breakout_config.min_candle_body_absolute = parse_decimal(
                request.POST.get('min_candle_body_absolute'))
            breakout_config.max_spread_ticks = parse_int(
                request.POST.get('max_spread_ticks'))
            breakout_config.filter_doji_breakouts = request.POST.get('filter_doji_breakouts') == 'on'
            
            # =========================================================
            # Advanced Filter settings (NEW)
            # =========================================================
            breakout_config.consecutive_candle_filter = parse_int(
                request.POST.get('consecutive_candle_filter'), 0)
            breakout_config.momentum_threshold = parse_decimal(
                request.POST.get('momentum_threshold'))
            breakout_config.volatility_throttle_min_atr = parse_decimal(
                request.POST.get('volatility_throttle_min_atr'))
            breakout_config.session_volatility_cap = parse_decimal(
                request.POST.get('session_volatility_cap'))
            
            # =========================================================
            # ATR settings (Extended)
            # =========================================================
            breakout_config.require_atr_minimum = request.POST.get('require_atr_minimum') == 'on'
            breakout_config.min_atr_value = parse_decimal(
                request.POST.get('min_atr_value'))
            breakout_config.max_atr_value = parse_decimal(
                request.POST.get('max_atr_value'))
            
            # =========================================================
            # Volume settings (NEW)
            # =========================================================
            breakout_config.min_volume_spike = parse_decimal(
                request.POST.get('min_volume_spike'))
            
            breakout_config.save()
            messages.success(request, 'Breakout-Konfiguration erfolgreich gespeichert.')
            return redirect('asset_detail', asset_id=asset.id)
            
        except (ValueError, InvalidOperation) as e:
            messages.error(request, f'Ungültige Eingabe: {e}')
    
    context = {
        'asset': asset,
        'config': breakout_config,
    }
    
    return render(request, 'trading/breakout_config_form.html', context)


@login_required
def event_config_edit(request, asset_id, phase=None):
    """
    Edit or create event configuration for an asset/phase.
    """
    from .models import TradingAsset, AssetEventConfig
    from django.contrib import messages
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    
    if request.method == 'POST':
        phase = request.POST.get('phase')
        event_type = request.POST.get('event_type', 'NONE')
        is_required = request.POST.get('is_required') == 'on'
        time_offset = int(request.POST.get('time_offset_minutes', 0))
        filter_enabled = request.POST.get('filter_enabled') == 'on'
        notes = request.POST.get('notes', '')
        
        # Get or create event config
        event_config, created = AssetEventConfig.objects.update_or_create(
            asset=asset,
            phase=phase,
            defaults={
                'event_type': event_type,
                'is_required': is_required,
                'time_offset_minutes': time_offset,
                'filter_enabled': filter_enabled,
                'notes': notes,
            }
        )
        
        action = 'erstellt' if created else 'aktualisiert'
        messages.success(request, f'Event-Konfiguration für {event_config.get_phase_display()} {action}.')
        return redirect('asset_detail', asset_id=asset.id)
    
    # Get existing config if editing
    event_config = None
    if phase:
        try:
            event_config = AssetEventConfig.objects.get(asset=asset, phase=phase)
        except AssetEventConfig.DoesNotExist:
            pass
    
    context = {
        'asset': asset,
        'config': event_config,
        'phase': phase,
        'session_phases': AssetEventConfig.SESSION_PHASES,
        'event_types': AssetEventConfig.EVENT_TYPES,
    }
    
    return render(request, 'trading/event_config_form.html', context)


@login_required
@require_http_methods(['POST'])
def event_config_delete(request, asset_id, phase):
    """
    Delete an event configuration.
    """
    from .models import TradingAsset, AssetEventConfig
    from django.contrib import messages
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    
    try:
        event_config = AssetEventConfig.objects.get(asset=asset, phase=phase)
        phase_display = event_config.get_phase_display()
        event_config.delete()
        messages.success(request, f'Event-Konfiguration für {phase_display} gelöscht.')
    except AssetEventConfig.DoesNotExist:
        messages.error(request, 'Event-Konfiguration nicht gefunden.')
    
    return redirect('asset_detail', asset_id=asset.id)


@login_required
def api_active_assets(request):
    """
    API endpoint returning all active assets with their configurations.
    Used by the worker to dynamically load assets.
    """
    from .models import TradingAsset, AssetSessionPhaseConfig
    
    assets = TradingAsset.objects.filter(is_active=True).prefetch_related(
        'breakout_config', 'event_configs', 'session_phase_configs'
    )
    
    result = []
    for asset in assets:
        asset_data = {
            'id': asset.id,
            'name': asset.name,
            'symbol': asset.symbol,
            'epic': asset.epic,
            'category': asset.category,
            'tick_size': str(asset.tick_size),
            'strategy_type': asset.strategy_type,
            'breakout_config': None,
            'event_configs': [],
            'session_phase_configs': [],
        }
        
        # Add breakout config if exists
        try:
            bc = asset.breakout_config
            asset_data['breakout_config'] = {
                # Asia Range
                'asia_range_start': bc.asia_range_start,
                'asia_range_end': bc.asia_range_end,
                'asia_min_range_ticks': bc.asia_min_range_ticks,
                'asia_max_range_ticks': bc.asia_max_range_ticks,
                # London Core (NEW)
                'london_range_start': bc.london_range_start,
                'london_range_end': bc.london_range_end,
                'london_min_range_ticks': bc.london_min_range_ticks,
                'london_max_range_ticks': bc.london_max_range_ticks,
                # US Core
                'pre_us_start': bc.pre_us_start,
                'pre_us_end': bc.pre_us_end,
                'us_min_range_ticks': bc.us_min_range_ticks,
                'us_max_range_ticks': bc.us_max_range_ticks,
                # US Core Trading
                'us_core_trading_start': bc.us_core_trading_start,
                'us_core_trading_end': bc.us_core_trading_end,
                'us_core_trading_enabled': bc.us_core_trading_enabled,
                # EIA Pre/Post (NEW)
                'eia_min_body_fraction': str(bc.eia_min_body_fraction),
                'eia_min_impulse_atr': str(bc.eia_min_impulse_atr) if bc.eia_min_impulse_atr else None,
                'eia_impulse_range_high': str(bc.eia_impulse_range_high) if bc.eia_impulse_range_high else None,
                'eia_impulse_range_low': str(bc.eia_impulse_range_low) if bc.eia_impulse_range_low else None,
                'eia_required_impulse_strength': str(bc.eia_required_impulse_strength),
                'eia_reversion_window_min_sec': bc.eia_reversion_window_min_sec,
                'eia_reversion_window_max_sec': bc.eia_reversion_window_max_sec,
                'eia_max_impulse_duration_min': bc.eia_max_impulse_duration_min,
                # Breakout Requirements
                'min_breakout_body_fraction': str(bc.min_breakout_body_fraction),
                'max_breakout_body_fraction': str(bc.max_breakout_body_fraction) if bc.max_breakout_body_fraction else None,
                'min_breakout_distance_ticks': bc.min_breakout_distance_ticks,
                # Candle Quality (NEW)
                'min_wick_ratio': str(bc.min_wick_ratio) if bc.min_wick_ratio else None,
                'max_wick_ratio': str(bc.max_wick_ratio) if bc.max_wick_ratio else None,
                'min_candle_body_absolute': str(bc.min_candle_body_absolute) if bc.min_candle_body_absolute else None,
                'max_spread_ticks': bc.max_spread_ticks,
                'filter_doji_breakouts': bc.filter_doji_breakouts,
                # Advanced Filter (NEW)
                'consecutive_candle_filter': bc.consecutive_candle_filter,
                'momentum_threshold': str(bc.momentum_threshold) if bc.momentum_threshold else None,
                'volatility_throttle_min_atr': str(bc.volatility_throttle_min_atr) if bc.volatility_throttle_min_atr else None,
                'session_volatility_cap': str(bc.session_volatility_cap) if bc.session_volatility_cap else None,
                # ATR (Extended)
                'require_atr_minimum': bc.require_atr_minimum,
                'min_atr_value': str(bc.min_atr_value) if bc.min_atr_value else None,
                'max_atr_value': str(bc.max_atr_value) if bc.max_atr_value else None,
                # Volume (NEW)
                'min_volume_spike': str(bc.min_volume_spike) if bc.min_volume_spike else None,
            }
        except Exception:
            pass
        
        # Add event configs (legacy)
        for ec in asset.event_configs.all():
            asset_data['event_configs'].append({
                'phase': ec.phase,
                'event_type': ec.event_type,
                'is_required': ec.is_required,
                'time_offset_minutes': ec.time_offset_minutes,
                'filter_enabled': ec.filter_enabled,
            })
        
        # Add new session phase configs
        for spc in asset.session_phase_configs.filter(enabled=True):
            asset_data['session_phase_configs'].append(spc.to_dict())
        
        result.append(asset_data)
    
    return JsonResponse({
        'success': True,
        'count': len(result),
        'assets': result,
    })
@login_required
def api_breakout_range_diagnostics(request):
    """
    GET /api/debug/breakout-range/ - Return breakout range diagnostic data.
    
    Query parameters:
        epic: Market identifier (optional, defaults to CC.D.CL.UNC.IP)
        range_type: Type of range to diagnose (optional, defaults to 'asia')
                    Values: 'asia', 'london_core', 'pre_us', 'us_core_trading', 'all'
        asset_id: Asset ID to use for loading persisted range data (optional)
    
    Returns JSON with:
        - Range type and period
        - Range high/low/height
        - Current price position relative to range
        - Breakout status
        - Configuration parameters
        - Diagnostic messages
        - Persisted range data (if available)
    """
    from datetime import datetime
    from core.services.strategy import (
        BreakoutRangeDiagnosticService,
        StrategyConfig,
        BaseMarketStateProvider,
        SessionPhase,
        Candle,
    )
    from .models import BreakoutRange, TradingAsset
    
    # Get query parameters
    epic = request.GET.get('epic', 'CC.D.CL.UNC.IP')
    range_type = request.GET.get('range_type', 'asia')
    asset_id = request.GET.get('asset_id')
    
    try:
        # Get current worker status for price and phase info
        status = WorkerStatus.get_current()
        
        # Try to load asset and its persisted ranges
        persisted_ranges = {}
        asset = None
        
        if asset_id:
            try:
                asset = TradingAsset.objects.get(id=asset_id)
                persisted_ranges = BreakoutRange.get_latest_for_asset(asset)
            except TradingAsset.DoesNotExist:
                pass
        elif epic:
            # Try to find asset by epic
            try:
                asset = TradingAsset.objects.get(epic=epic)
                persisted_ranges = BreakoutRange.get_latest_for_asset(asset)
            except TradingAsset.DoesNotExist:
                pass
        
        # Create a market state provider using persisted data and worker status
        class PersistentMarketStateProvider(BaseMarketStateProvider):
            """Provider using persisted range data and WorkerStatus."""
            
            def __init__(self, worker_status, persisted_ranges):
                self._status = worker_status
                self._persisted_ranges = persisted_ranges
                # Gracefully handle invalid phase values
                try:
                    self._phase = SessionPhase(worker_status.phase) if worker_status and worker_status.phase else SessionPhase.OTHER
                except ValueError:
                    self._phase = SessionPhase.OTHER
            
            def get_phase(self, ts):
                return self._phase
            
            def get_recent_candles(self, epic, timeframe, limit):
                # Return empty list - we don't have candle data
                return []
            
            def get_asia_range(self, epic):
                range_data = self._persisted_ranges.get('ASIA_RANGE')
                if range_data:
                    return (float(range_data.high), float(range_data.low))
                return None
            
            def get_london_core_range(self, epic):
                range_data = self._persisted_ranges.get('LONDON_CORE')
                if range_data:
                    return (float(range_data.high), float(range_data.low))
                return None
            
            def get_pre_us_range(self, epic):
                range_data = self._persisted_ranges.get('PRE_US_RANGE')
                if range_data:
                    return (float(range_data.high), float(range_data.low))
                return None
            
            def get_atr(self, epic, timeframe, period):
                # Try to get ATR from most recent persisted range
                for phase_key in ['US_CORE_TRADING', 'PRE_US_RANGE', 'LONDON_CORE', 'ASIA_RANGE']:
                    range_data = self._persisted_ranges.get(phase_key)
                    if range_data and range_data.atr:
                        return float(range_data.atr)
                return None
        
        # Create diagnostic service
        provider = PersistentMarketStateProvider(status, persisted_ranges)
        
        # Get asset-specific config if available
        if asset:
            try:
                config = asset.get_strategy_config()
            except Exception:
                config = StrategyConfig()
        else:
            config = StrategyConfig()
        
        service = BreakoutRangeDiagnosticService(provider, config)
        
        # Get current price from asset-specific price status (for multi-asset support)
        # Fall back to global worker status only if no asset-specific price is available
        current_price = None
        if asset:
            price_status = AssetPriceStatus.get_for_asset(asset)
            if price_status and price_status.bid_price and price_status.ask_price:
                current_price = float((price_status.bid_price + price_status.ask_price) / 2)
            elif price_status and price_status.bid_price:
                current_price = float(price_status.bid_price)
        
        # Fall back to worker status if no asset-specific price
        if current_price is None:
            if status and status.bid_price and status.ask_price:
                current_price = float((status.bid_price + status.ask_price) / 2)
            elif status and status.bid_price:
                current_price = float(status.bid_price)
        
        # Get diagnostics based on range type
        ts = timezone.now()
        
        if range_type == 'all':
            # Return all phases
            all_diagnostics = service.get_all_phase_diagnostics(epic, ts, current_price)
            return JsonResponse({
                'success': True,
                'epic': epic,
                'range_type': 'all',
                'data': {k: v.to_dict() for k, v in all_diagnostics.items()},
                'persisted_ranges': {k: v.to_dict() for k, v in persisted_ranges.items()},
                'worker_status': {
                    'phase': status.phase if status else None,
                    'last_run_at': status.last_run_at.isoformat() if status and status.last_run_at else None,
                },
            })
        elif range_type == 'london_core':
            diagnostics = service.get_london_core_range_diagnostics(epic, ts, current_price)
        elif range_type == 'pre_us':
            diagnostics = service.get_pre_us_range_diagnostics(epic, ts, current_price)
        elif range_type == 'us_core_trading':
            diagnostics = service.get_us_core_trading_diagnostics(epic, ts, current_price)
        else:
            diagnostics = service.get_asia_range_diagnostics(epic, ts, current_price)
        
        # Get persisted range for this specific type
        phase_mapping = {
            'asia': 'ASIA_RANGE',
            'london_core': 'LONDON_CORE',
            'pre_us': 'PRE_US_RANGE',
            'us_core_trading': 'US_CORE_TRADING',
        }
        persisted_range = persisted_ranges.get(phase_mapping.get(range_type, 'ASIA_RANGE'))
        
        return JsonResponse({
            'success': True,
            'epic': epic,
            'range_type': range_type,
            'data': diagnostics.to_dict(),
            'persisted_range': persisted_range.to_dict() if persisted_range else None,
            'worker_status': {
                'phase': status.phase if status else None,
                'last_run_at': status.last_run_at.isoformat() if status and status.last_run_at else None,
            },
        })
        
    except Exception as e:
        logger.error(f"Error fetching breakout range diagnostics: {e}")
        return JsonResponse({
            'success': False,
            'error': f'Fehler beim Abrufen der Range-Diagnose: {str(e)}',
            'data': None,
        }, status=500)


@login_required
def api_breakout_range_history(request, asset_id):
    """
    GET /api/assets/{asset_id}/breakout-ranges/ - Return breakout range history for an asset.
    
    Query parameters:
        phase: Filter by phase (optional, e.g., 'ASIA_RANGE', 'LONDON_CORE', 'PRE_US_RANGE', 'US_CORE_TRADING')
        limit: Maximum number of records to return (optional, default 20)
    
    Returns JSON with list of breakout range records.
    """
    from .models import BreakoutRange, TradingAsset
    
    try:
        asset = get_object_or_404(TradingAsset, id=asset_id)
        
        # Get query parameters with validation
        phase = request.GET.get('phase')
        try:
            limit = int(request.GET.get('limit', 20))
        except (ValueError, TypeError):
            limit = 20
        # Enforce maximum limit to prevent performance issues
        limit = min(max(limit, 1), 100)
        
        # Build query
        queryset = BreakoutRange.objects.filter(asset=asset)
        if phase:
            queryset = queryset.filter(phase=phase)
        
        queryset = queryset.order_by('-end_time')[:limit]
        
        ranges_data = [r.to_dict() for r in queryset]
        
        return JsonResponse({
            'success': True,
            'asset_id': asset.id,
            'asset_symbol': asset.symbol,
            'count': len(ranges_data),
            'ranges': ranges_data,
        })
        
    except Exception as e:
        logger.error(f"Error fetching breakout range history: {e}")
        return JsonResponse({
            'success': False,
            'error': f'Fehler beim Abrufen der Range-Historie: {str(e)}',
        }, status=500)


@login_required
def api_breakout_range_latest(request, asset_id):
    """
    GET /api/assets/{asset_id}/breakout-ranges/latest/ - Return latest breakout range for each phase.
    
    Returns JSON with the most recent breakout range for each phase.
    """
    from .models import BreakoutRange, TradingAsset
    
    try:
        asset = get_object_or_404(TradingAsset, id=asset_id)
        
        # Get latest ranges for all phases
        latest_ranges = BreakoutRange.get_latest_for_asset(asset)
        
        ranges_data = {k: v.to_dict() for k, v in latest_ranges.items()}
        
        return JsonResponse({
            'success': True,
            'asset_id': asset.id,
            'asset_symbol': asset.symbol,
            'ranges': ranges_data,
        })
        
    except Exception as e:
        logger.error(f"Error fetching latest breakout ranges: {e}")
        return JsonResponse({
            'success': False,
            'error': f'Fehler beim Abrufen der aktuellen Ranges: {str(e)}',
        }, status=500)


@login_required
def api_price_range_status(request):
    """
    GET /api/price-range-status/ - Return price vs range live status.
    
    Query parameters:
        asset_id: Required - Asset ID to compute status for
        phase: Required - Session phase ('ASIA_RANGE', 'LONDON_CORE', 'PRE_US_RANGE', 'US_CORE_TRADING')
    
    Returns JSON with:
        - Range data (high, low, height in ticks)
        - Current price (bid/ask)
        - Distance to range boundaries (in ticks)
        - Status code and text (INSIDE_RANGE, NEAR_BREAKOUT_*, BREAKOUT_*, NO_RANGE)
        - Badge color for UI display
        
    This endpoint uses persisted data only - no IG API calls.
    """
    from .services.price_range_status import compute_price_range_status, get_phase_display_name
    
    # Get required parameters
    asset_id = request.GET.get('asset_id')
    phase = request.GET.get('phase')
    
    # Validate parameters
    if not asset_id:
        return JsonResponse({
            'success': False,
            'error': 'asset_id is required',
        }, status=400)
    
    if not phase:
        return JsonResponse({
            'success': False,
            'error': 'phase is required',
        }, status=400)
    
    # Validate phase value
    valid_phases = ['ASIA_RANGE', 'LONDON_CORE', 'PRE_US_RANGE', 'US_CORE_TRADING']
    if phase not in valid_phases:
        return JsonResponse({
            'success': False,
            'error': f'Invalid phase. Must be one of: {", ".join(valid_phases)}',
        }, status=400)
    
    try:
        # Get asset
        asset = get_object_or_404(TradingAsset, id=asset_id)
        
        # Compute price range status
        status = compute_price_range_status(asset, phase)
        
        # Get current worker status for additional context
        worker_status = WorkerStatus.get_current()
        
        return JsonResponse({
            'success': True,
            'data': status.to_dict(),
            'phase_display': get_phase_display_name(phase),
            'worker_status': {
                'phase': worker_status.phase if worker_status else None,
                'last_run_at': worker_status.last_run_at.isoformat() if worker_status and worker_status.last_run_at else None,
            },
        })
        
    except Exception as e:
        logger.error(f"Error computing price range status: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Fehler beim Berechnen des Preis-Range-Status',
        }, status=500)


@login_required
def htmx_price_range_status(request):
    """
    HTMX partial view for Price vs Range - Live Status panel.
    
    Query parameters:
        asset_id: Required - Asset ID to compute status for
        phase: Required - Session phase ('ASIA_RANGE', 'LONDON_CORE', 'PRE_US_RANGE', 'US_CORE_TRADING')
    
    Returns an HTML partial that can be loaded via HTMX.
    """
    from .services.price_range_status import compute_price_range_status, get_phase_display_name
    
    # Get required parameters
    asset_id = request.GET.get('asset_id')
    phase = request.GET.get('phase', 'ASIA_RANGE')
    
    context = {
        'error': None,
        'status': None,
        'phase': phase,
        'phase_display': get_phase_display_name(phase),
        'asset_id': asset_id,
    }
    
    if not asset_id:
        context['error'] = 'Kein Asset ausgewählt'
        return render(request, 'trading/partials/price_range_status.html', context)
    
    try:
        # Get asset - use get_object_or_404 for consistency
        asset = get_object_or_404(TradingAsset, id=asset_id)
        
        # Compute price range status
        status = compute_price_range_status(asset, phase)
        
        # Get current worker status for additional context
        worker_status = WorkerStatus.get_current()
        
        context.update({
            'status': status,
            'asset': asset,
            'worker_phase': worker_status.phase if worker_status else None,
        })
        
    except Http404:
        context['error'] = 'Asset nicht gefunden'
    except Exception as e:
        logger.error(f"Error computing price range status for HTMX: {e}")
        context['error'] = 'Fehler beim Berechnen des Status'
    
    return render(request, 'trading/partials/price_range_status.html', context)


# ============================================================================
# Trading Diagnostics Views
# ============================================================================

@login_required
def diagnostics_view(request):
    """
    Trading Diagnostics View - Sanity & Confidence Layer.
    
    Displays diagnostic information for all active trading assets including:
    - Current phase and trading mode
    - Last worker cycle timestamp
    - Counters (candles, ranges, setups, orders)
    - Top rejection reason codes
    
    This is a separate page from the main dashboard, designed for
    mobile-friendly access to understand why (not) trading is happening.
    """
    # Get time window from request
    window = request.GET.get('window', str(DIAGNOSTICS_DEFAULT_WINDOW_MINUTES))
    window_minutes = _parse_window_minutes(window)
    
    # Calculate time window
    now = timezone.now()
    window_start = now - timedelta(minutes=window_minutes)
    
    # Get all active assets
    assets = TradingAsset.objects.filter(is_active=True).prefetch_related('diagnostics')
    
    # Build diagnostics data for each asset
    asset_diagnostics = []
    for asset in assets:
        # Get aggregated diagnostics for the time window
        diagnostics_data = AssetDiagnostics.get_aggregated_for_period(
            asset, window_start, now
        )
        
        # Add asset info
        diagnostics_data['asset'] = asset
        asset_diagnostics.append(diagnostics_data)
    
    context = {
        'asset_diagnostics': asset_diagnostics,
        'window_minutes': window_minutes,
        'window_start': window_start,
        'window_end': now,
        'window_options': [
            {'value': 15, 'label': 'Letzte 15 Min'},
            {'value': 60, 'label': 'Letzte 60 Min'},
            {'value': 240, 'label': 'Letzte 4 Std'},
            {'value': 1440, 'label': 'Heute (24h)'},
        ],
    }
    
    return render(request, 'trading/diagnostics.html', context)


@login_required
def api_diagnostics(request):
    """
    GET /api/trading/diagnostics/ - Return diagnostics data for all active assets.
    
    Query parameters:
        asset: Optional asset ID to filter for a specific asset
        window: Time window in minutes (15, 60, 240, 1440) - default: 60
    
    Returns JSON with diagnostics data for each asset including:
    - Current phase and trading mode
    - Last cycle timestamp
    - Counters (candles, ranges, setups, orders)
    - Top rejection reason codes
    """
    try:
        # Get query parameters
        asset_id = request.GET.get('asset')
        window = request.GET.get('window', str(DIAGNOSTICS_DEFAULT_WINDOW_MINUTES))
        window_minutes = _parse_window_minutes(window)
        
        # Calculate time window
        now = timezone.now()
        window_start = now - timedelta(minutes=window_minutes)
        
        # Get assets
        if asset_id:
            try:
                assets = TradingAsset.objects.filter(id=asset_id, is_active=True)
            except ValueError:
                return JsonResponse({
                    'success': False,
                    'error': 'Invalid asset ID',
                }, status=400)
        else:
            assets = TradingAsset.objects.filter(is_active=True)
        
        # Build diagnostics data for each asset
        diagnostics_list = []
        for asset in assets:
            diagnostics_data = AssetDiagnostics.get_aggregated_for_period(
                asset, window_start, now
            )
            # Add additional asset info
            diagnostics_data['asset_symbol'] = asset.symbol
            diagnostics_data['asset_name'] = asset.name
            diagnostics_data['asset_epic'] = asset.epic
            diagnostics_list.append(diagnostics_data)
        
        return JsonResponse({
            'success': True,
            'window_start': window_start.isoformat(),
            'window_end': now.isoformat(),
            'window_minutes': window_minutes,
            'count': len(diagnostics_list),
            'diagnostics': diagnostics_list,
        })
        
    except Exception as e:
        logger.error(f"Error fetching diagnostics: {e}")
        return JsonResponse({
            'success': False,
            'error': f'Fehler beim Abrufen der Diagnostics: {str(e)}',
        }, status=500)


@login_required
@require_http_methods(['POST'])
def asset_toggle_trading_mode(request, asset_id):
    """
    Toggle the trading mode of an asset between STRICT and DIAGNOSTIC via HTMX/AJAX.
    """
    asset = get_object_or_404(TradingAsset, id=asset_id)
    
    # Toggle trading mode
    if asset.trading_mode == 'STRICT':
        asset.trading_mode = 'DIAGNOSTIC'
    else:
        asset.trading_mode = 'STRICT'
    asset.save()
    
    return JsonResponse({
        'success': True,
        'trading_mode': asset.trading_mode,
        'is_diagnostic': asset.is_diagnostic_mode,
        'message': f'Trading Mode für "{asset.name}" auf {asset.get_trading_mode_display()} gesetzt.',
    })
# Session Phase Configuration Views
# ============================================================================

@login_required
def phase_config_list(request, asset_id):
    """
    List all session phase configurations for an asset.
    Displays "Sessions & Phases" overview with all phases.
    """
    from .models import TradingAsset, AssetSessionPhaseConfig
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    phase_configs = AssetSessionPhaseConfig.get_phases_for_asset(asset)
    
    # Create a mapping of all possible phases with their current config (or None)
    all_phases = dict(AssetSessionPhaseConfig.PHASE_CHOICES)
    phase_map = {pc.phase: pc for pc in phase_configs}
    
    context = {
        'asset': asset,
        'phase_configs': phase_configs,
        'all_phases': all_phases,
        'phase_map': phase_map,
        'phase_choices': AssetSessionPhaseConfig.PHASE_CHOICES,
        'event_type_choices': AssetSessionPhaseConfig.EVENT_TYPE_CHOICES,
    }
    
    return render(request, 'trading/phase_config_list.html', context)


@login_required
@require_http_methods(['POST'])
def phase_config_create_defaults(request, asset_id):
    """
    Create default phase configurations for an asset.
    """
    from .models import TradingAsset, AssetSessionPhaseConfig
    from django.contrib import messages
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    
    # Create default phases
    created = AssetSessionPhaseConfig.create_default_phases_for_asset(asset)
    
    if created:
        messages.success(request, f'{len(created)} Standard-Phasen wurden erstellt.')
    else:
        messages.info(request, 'Alle Standard-Phasen existieren bereits.')
    
    return redirect('phase_config_list', asset_id=asset.id)


@login_required
def phase_config_edit(request, asset_id, phase):
    """
    Create or edit a session phase configuration.
    """
    from .models import TradingAsset, AssetSessionPhaseConfig
    from django.contrib import messages
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    
    # Get existing config or None
    try:
        config = AssetSessionPhaseConfig.objects.get(asset=asset, phase=phase)
    except AssetSessionPhaseConfig.DoesNotExist:
        config = None
    
    if request.method == 'POST':
        # Parse form data
        start_time_utc = request.POST.get('start_time_utc', '00:00')
        end_time_utc = request.POST.get('end_time_utc', '00:00')
        is_range_build_phase = request.POST.get('is_range_build_phase') == 'on'
        is_trading_phase = request.POST.get('is_trading_phase') == 'on'
        event_type = request.POST.get('event_type', 'NONE')
        requires_event = request.POST.get('requires_event') == 'on'
        try:
            event_offset_minutes = int(request.POST.get('event_offset_minutes', 0))
        except (ValueError, TypeError):
            event_offset_minutes = 0
        enabled = request.POST.get('enabled') == 'on'
        notes = request.POST.get('notes', '')
        
        # Create or update
        if config:
            config.start_time_utc = start_time_utc
            config.end_time_utc = end_time_utc
            config.is_range_build_phase = is_range_build_phase
            config.is_trading_phase = is_trading_phase
            config.event_type = event_type
            config.requires_event = requires_event
            config.event_offset_minutes = event_offset_minutes
            config.enabled = enabled
            config.notes = notes
            config.save()
            messages.success(request, f'Phase "{config.get_phase_display()}" aktualisiert.')
        else:
            config = AssetSessionPhaseConfig.objects.create(
                asset=asset,
                phase=phase,
                start_time_utc=start_time_utc,
                end_time_utc=end_time_utc,
                is_range_build_phase=is_range_build_phase,
                is_trading_phase=is_trading_phase,
                event_type=event_type,
                requires_event=requires_event,
                event_offset_minutes=event_offset_minutes,
                enabled=enabled,
                notes=notes,
            )
            messages.success(request, f'Phase "{config.get_phase_display()}" erstellt.')
        
        return redirect('phase_config_list', asset_id=asset.id)
    
    # GET request - show form
    context = {
        'asset': asset,
        'config': config,
        'phase': phase,
        'phase_display': dict(AssetSessionPhaseConfig.PHASE_CHOICES).get(phase, phase),
        'phase_choices': AssetSessionPhaseConfig.PHASE_CHOICES,
        'event_type_choices': AssetSessionPhaseConfig.EVENT_TYPE_CHOICES,
    }
    
    return render(request, 'trading/phase_config_form.html', context)


@login_required
@require_http_methods(['POST'])
def phase_config_delete(request, asset_id, phase):
    """
    Delete a session phase configuration.
    """
    from .models import TradingAsset, AssetSessionPhaseConfig
    from django.contrib import messages
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    
    try:
        config = AssetSessionPhaseConfig.objects.get(asset=asset, phase=phase)
        phase_display = config.get_phase_display()
        config.delete()
        messages.success(request, f'Phase "{phase_display}" gelöscht.')
    except AssetSessionPhaseConfig.DoesNotExist:
        messages.error(request, 'Phasen-Konfiguration nicht gefunden.')
    
    return redirect('phase_config_list', asset_id=asset.id)


@login_required
@require_http_methods(['POST'])
def phase_config_toggle(request, asset_id, phase):
    """
    Toggle the enabled status of a session phase configuration via AJAX.
    """
    from .models import TradingAsset, AssetSessionPhaseConfig
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    
    try:
        config = AssetSessionPhaseConfig.objects.get(asset=asset, phase=phase)
        config.enabled = not config.enabled
        config.save()
        
        return JsonResponse({
            'success': True,
            'enabled': config.enabled,
            'message': f'Phase "{config.get_phase_display()}" ist jetzt {"aktiviert" if config.enabled else "deaktiviert"}.',
        })
    except AssetSessionPhaseConfig.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Phasen-Konfiguration nicht gefunden.',
        }, status=404)


@login_required
def api_phase_configs(request, asset_id):
    """
    API endpoint for phase configurations.
    
    GET: Returns all phase configurations for an asset.
    POST: Create or update a phase configuration.
    PUT: Update a phase configuration (expects JSON body).
    """
    from .models import TradingAsset, AssetSessionPhaseConfig
    import json
    
    asset = get_object_or_404(TradingAsset, id=asset_id)
    
    if request.method == 'GET':
        # Return all phase configurations
        configs = AssetSessionPhaseConfig.get_phases_for_asset(asset)
        return JsonResponse({
            'success': True,
            'asset_id': asset.id,
            'asset_symbol': asset.symbol,
            'count': configs.count(),
            'phases': [c.to_dict() for c in configs],
        })
    
    elif request.method == 'POST':
        # Create or update phase configuration
        try:
            data = json.loads(request.body)
            phase = data.get('phase')
            
            if not phase:
                return JsonResponse({
                    'success': False,
                    'error': 'Phase is required.',
                }, status=400)
            
            # Validate phase
            valid_phases = [p[0] for p in AssetSessionPhaseConfig.PHASE_CHOICES]
            if phase not in valid_phases:
                return JsonResponse({
                    'success': False,
                    'error': f'Invalid phase. Must be one of: {", ".join(valid_phases)}',
                }, status=400)
            
            # Create or update
            config, created = AssetSessionPhaseConfig.objects.update_or_create(
                asset=asset,
                phase=phase,
                defaults={
                    'start_time_utc': data.get('start_time_utc', '00:00'),
                    'end_time_utc': data.get('end_time_utc', '00:00'),
                    'is_range_build_phase': data.get('is_range_build_phase', False),
                    'is_trading_phase': data.get('is_trading_phase', False),
                    'event_type': data.get('event_type', 'NONE'),
                    'requires_event': data.get('requires_event', False),
                    'event_offset_minutes': data.get('event_offset_minutes', 0),
                    'enabled': data.get('enabled', True),
                    'notes': data.get('notes', ''),
                }
            )
            
            return JsonResponse({
                'success': True,
                'created': created,
                'phase': config.to_dict(),
            })
            
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Invalid JSON body.',
            }, status=400)
        except Exception as e:
            logger.error(f"Error creating/updating phase config: {e}")
            return JsonResponse({
                'success': False,
                'error': str(e),
            }, status=500)
    
    return JsonResponse({
        'success': False,
        'error': 'Method not allowed.',
    }, status=405)


@login_required
def api_breakout_distance_chart(request, asset_code):
    """
    GET /api/assets/{asset_code}/diagnostics/breakout-distance-chart - Return breakout distance chart data.
    
    Path parameters:
        asset_code: Asset symbol (e.g., 'OIL', 'NAS100')
    
    Query parameters:
        phase: Required - Session phase ('LONDON_CORE', 'US_CORE_TRADING', 'PRE_US_RANGE', 'EIA_PRE', 'EIA_POST')
    
    Returns JSON with:
        - asset: Asset symbol
        - phase: Current phase
        - reference_phase: Reference phase used for range (e.g., 'ASIA_RANGE', 'PRE_US_RANGE')
        - range: Range data (high, low, tick_size, min_breakout_ticks, breakout_long_level, breakout_short_level)
        - trend: Trend indicator ('up', 'down', 'sideways')
        - prices: Array of price points with timestamp and price
        - error: Optional error message if data unavailable
        
    This endpoint uses persisted data only - no IG API calls.
    """
    from .services.breakout_distance_chart import get_breakout_distance_chart_data_by_code, REFERENCE_PHASE_MAPPING
    
    # Get required phase parameter
    phase = request.GET.get('phase')
    
    if not phase:
        return JsonResponse({
            'success': False,
            'error': 'phase is required',
        }, status=400)
    
    # Validate phase value (must have a reference phase mapping)
    valid_phases = list(REFERENCE_PHASE_MAPPING.keys())
    if phase not in valid_phases:
        return JsonResponse({
            'success': False,
            'error': f"No breakout distance chart available for phase '{phase}'.",
        }, status=400)
    
    try:
        # Get chart data
        chart_data = get_breakout_distance_chart_data_by_code(asset_code, phase)
        
        # Check for errors in chart data
        if chart_data.error:
            # Return 404 for "not found" errors, 200 for data availability issues
            if 'not found' in chart_data.error.lower():
                return JsonResponse({
                    'success': False,
                    'error': chart_data.error,
                }, status=404)
            return JsonResponse({
                'success': False,
                'error': chart_data.error,
            })
        
        return JsonResponse({
            'success': True,
            **chart_data.to_dict(),
        })
        
    except Exception as e:
        logger.error(f"Error getting breakout distance chart data: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Fehler beim Laden der Chart-Daten',
        }, status=500)


@login_required
def api_breakout_distance_chart_by_id(request, asset_id):
    """
    GET /api/assets/{asset_id}/diagnostics/breakout-distance-chart/ - Return breakout distance chart data by asset ID.
    
    Path parameters:
        asset_id: Asset database ID
    
    Query parameters:
        phase: Required - Session phase ('LONDON_CORE', 'US_CORE_TRADING', 'PRE_US_RANGE', 'EIA_PRE', 'EIA_POST')
    
    Returns JSON with same structure as api_breakout_distance_chart.
    """
    from .services.breakout_distance_chart import get_breakout_distance_chart_data, REFERENCE_PHASE_MAPPING
    
    # Get required phase parameter
    phase = request.GET.get('phase')
    
    if not phase:
        return JsonResponse({
            'success': False,
            'error': 'phase is required',
        }, status=400)
    
    # Validate phase value
    valid_phases = list(REFERENCE_PHASE_MAPPING.keys())
    if phase not in valid_phases:
        return JsonResponse({
            'success': False,
            'error': f"No breakout distance chart available for phase '{phase}'.",
        }, status=400)
    
    try:
        # Get asset
        asset = get_object_or_404(TradingAsset, id=asset_id)
        
        # Get chart data
        chart_data = get_breakout_distance_chart_data(asset, phase)
        
        # Check for errors in chart data
        if chart_data.error:
            # Data availability issues return 200 with error message
            return JsonResponse({
                'success': False,
                'error': chart_data.error,
            })
        
        return JsonResponse({
            'success': True,
            **chart_data.to_dict(),
        })
        
    except Exception as e:
        logger.error(f"Error getting breakout distance chart data: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Fehler beim Laden der Chart-Daten',
        }, status=500)


# ============================================================================
# Breakout Distance Chart v1 API Endpoints
# ============================================================================

@login_required
def api_chart_candles(request, asset_code):
    """
    GET /api/chart/{asset}/candles - Return 5-minute candlestick data.
    
    Path parameters:
        asset_code: Asset symbol (e.g., 'OIL', 'NAS100')
    
    Query parameters:
        tf: Timeframe (default: '5m', currently only 5m supported)
        hours: Time window (1, 3, 6, 8, 12, 24) - default: 1
    
    Returns JSON with:
        - asset: Asset symbol
        - timeframe: Candle timeframe
        - hours: Time window requested
        - candle_count: Number of candles
        - candles: Array of OHLC data with unix timestamps
    """
    # Get query parameters
    timeframe = request.GET.get('tf', '5m')
    try:
        hours = int(request.GET.get('hours', 1))
    except (ValueError, TypeError):
        hours = 1
    
    # Validate hours
    if hours not in SUPPORTED_TIME_WINDOWS:
        return JsonResponse({
            'success': False,
            'error': f'Invalid hours value. Must be one of: {SUPPORTED_TIME_WINDOWS}',
        }, status=400)
    
    # Get asset
    asset = get_asset_by_symbol(asset_code)
    if not asset:
        return JsonResponse({
            'success': False,
            'error': f"Asset '{asset_code}' not found or not active.",
        }, status=404)
    
    try:
        # Get candle data
        result = get_candles_for_asset(asset, hours=hours, timeframe=timeframe)
        
        if result.error:
            return JsonResponse({
                'success': False,
                'error': result.error,
            })
        
        return JsonResponse({
            'success': True,
            **result.to_dict(),
        })
        
    except Exception as e:
        logger.error(f"Error getting chart candles: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Fehler beim Laden der Kerzen-Daten',
        }, status=500)


@login_required
def api_chart_breakout_context(request, asset_code):
    """
    GET /api/chart/{asset}/breakout-context - Return breakout context data.
    
    Path parameters:
        asset_code: Asset symbol (e.g., 'OIL', 'NAS100')
    
    Returns JSON with:
        - phase: Current session phase
        - reference_phase: Reference range phase
        - range_high/low: Current reference range boundaries
        - breakout_long_level/short_level: Breakout trigger levels
        - current_price: Current market price
        - distance_to_high/low_ticks: Distance to range boundaries
        - is_above/below/inside_range: Position flags
    """
    # Get asset
    asset = get_asset_by_symbol(asset_code)
    if not asset:
        return JsonResponse({
            'success': False,
            'error': f"Asset '{asset_code}' not found or not active.",
        }, status=404)
    
    try:
        # Get breakout context
        context = get_breakout_context_for_asset(asset)
        
        return JsonResponse({
            'success': True,
            **context.to_dict(),
        })
        
    except Exception as e:
        logger.error(f"Error getting breakout context: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Fehler beim Laden des Breakout-Kontexts',
        }, status=500)


@login_required
def api_chart_session_ranges(request, asset_code):
    """
    GET /api/chart/{asset}/session-ranges - Return session range data.
    
    Path parameters:
        asset_code: Asset symbol (e.g., 'OIL', 'NAS100')
    
    Query parameters:
        hours: Time window for range lookup (default: 24)
    
    Returns JSON with:
        - asset: Asset symbol
        - hours: Time window
        - ranges: Dict of session ranges with high/low/timestamps
          - ASIA_RANGE
          - LONDON_CORE
          - PRE_US_RANGE
          - US_CORE_TRADING
    """
    # Get query parameters
    try:
        hours = int(request.GET.get('hours', 24))
    except (ValueError, TypeError):
        hours = 24
    
    # Get asset
    asset = get_asset_by_symbol(asset_code)
    if not asset:
        return JsonResponse({
            'success': False,
            'error': f"Asset '{asset_code}' not found or not active.",
        }, status=404)
    
    try:
        # Get session ranges
        result = get_session_ranges_for_asset(asset, hours=hours)
        
        if result.error:
            return JsonResponse({
                'success': False,
                'error': result.error,
            })
        
        return JsonResponse({
            'success': True,
            **result.to_dict(),
        })
        
    except Exception as e:
        logger.error(f"Error getting session ranges: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Fehler beim Laden der Session-Ranges',
        }, status=500)


@login_required
def breakout_distance_chart_view(request):
    """
    Breakout Distance Chart View - Interactive chart with Lightweight Charts.
    
    Displays:
    - 5-minute candlestick data from IG
    - Session ranges (Asia, London, US Core) with toggle switches
    - Breakout levels as price lines
    - Info panel with current phase, range, and tick distances
    
    Query parameters:
        asset: Asset symbol (default: first active asset)
        hours: Time window (1, 3, 6, 8, 12, 24) - default: 6
    """
    # Get active assets for the selector
    active_assets = TradingAsset.objects.filter(is_active=True).order_by('name')
    
    # Get selected asset from query params or default to first
    selected_asset_code = request.GET.get('asset')
    selected_asset = None
    
    if selected_asset_code:
        try:
            selected_asset = TradingAsset.objects.get(symbol__iexact=selected_asset_code, is_active=True)
        except TradingAsset.DoesNotExist:
            pass
    
    if not selected_asset and active_assets.exists():
        selected_asset = active_assets.first()
    
    # Get hours from query params
    try:
        selected_hours = int(request.GET.get('hours', 6))
    except (ValueError, TypeError):
        selected_hours = 6
    
    if selected_hours not in SUPPORTED_TIME_WINDOWS:
        selected_hours = 6
    
    context = {
        'active_assets': active_assets,
        'selected_asset': selected_asset,
        'selected_hours': selected_hours,
        'time_windows': SUPPORTED_TIME_WINDOWS,
    }
    
    return render(request, 'trading/breakout_distance_chart.html', context)


# ============================================================================
# Market Data Layer - Realtime Breakout Distance Candles API
# ============================================================================

@login_required
def api_breakout_distance_candles(request):
    """
    GET /trading/api/breakout-distance-candles - Return candles via the Market Data Layer.
    
    This is the new broker-agnostic endpoint that uses the Market Data Layer
    with Redis-backed persistence. It removes the 24h hard limit and provides
    flexible window sizes.
    
    Query parameters:
        asset_id: Required - Asset ID to fetch candles for
        timeframe: Candle timeframe (default: '1m', options: 1m, 5m, 15m, 1h)
        window: Time window in hours (default: 6, options: 1, 3, 6, 8, 12, 24, 48, 72)
    
    Returns JSON with:
        - success: Whether the request was successful
        - asset: Asset symbol
        - timeframe: Candle timeframe
        - window_hours: Time window in hours
        - candle_count: Number of candles returned
        - candles: Array of OHLC candles with unix timestamps
        - status: Data stream status object:
            - status: 'LIVE', 'POLL', 'CACHED', or 'OFFLINE'
            - last_update: Timestamp of last data update
            - candle_count: Number of candles in buffer
            - broker: Broker providing the data
            - error: Error message if status is OFFLINE
        - error: Optional error message
    """
    from core.services.market_data import get_stream_manager, SUPPORTED_WINDOW_HOURS
    
    # Get required asset_id parameter
    asset_id = request.GET.get('asset_id')
    if not asset_id:
        return JsonResponse({
            'success': False,
            'error': 'asset_id is required',
        }, status=400)
    
    # Get optional timeframe parameter
    timeframe = request.GET.get('timeframe', '1m')
    
    # Get optional window parameter
    try:
        window_hours = float(request.GET.get('window', 6))
    except (ValueError, TypeError):
        window_hours = 6
    
    try:
        # Get the asset
        try:
            asset = TradingAsset.objects.get(id=asset_id, is_active=True)
        except TradingAsset.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': f'Asset with ID {asset_id} not found or not active.',
            }, status=404)
        
        # Get the stream manager and fetch candles
        manager = get_stream_manager()
        response = manager.get_candles(
            asset=asset,
            timeframe=timeframe,
            window_hours=window_hours,
        )
        
        return JsonResponse({
            'success': True,
            **response.to_dict(),
        })
        
    except Exception as e:
        logger.error(f"Error fetching breakout distance candles: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Error loading candle data',
        }, status=500)


@login_required
def api_market_data_status(request):
    """
    GET /trading/api/market-data/status - Return status of all active market data streams.
    
    Returns JSON with:
        - success: Whether the request was successful
        - streams: Array of stream status objects
        - total_streams: Total number of active streams
    """
    from core.services.market_data import get_stream_manager
    
    try:
        manager = get_stream_manager()
        statuses = manager.get_all_stream_statuses()
        
        return JsonResponse({
            'success': True,
            'total_streams': len(statuses),
            'streams': [s.to_dict() for s in statuses],
        })
        
    except Exception as e:
        logger.error(f"Error fetching market data status: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Error retrieving market data status',
        }, status=500)
