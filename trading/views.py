import logging

from django.shortcuts import render, get_object_or_404, redirect
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.contrib.auth.decorators import login_required
from django.core.paginator import Paginator
from django.core.exceptions import ImproperlyConfigured
from django.utils import timezone

from .models import Signal, Trade, WorkerStatus
from core.services.broker import create_ig_broker_service, BrokerError, AuthenticationError

logger = logging.getLogger(__name__)


@login_required
def signal_dashboard(request):
    """
    Signal Dashboard - Main view showing all active trading signals.
    
    Displays signals from the database that are generated by the real
    Strategy Engine, KI Layer, and Risk Engine services.
    """
    signals = Signal.objects.filter(status='ACTIVE')
    active_count = signals.count()
    
    context = {
        'signals': signals,
        'active_count': active_count,
    }
    
    return render(request, 'trading/signal_dashboard.html', context)


@login_required
def signal_detail(request, signal_id):
    """
    Trade Detail Panel - Detailed view of a specific signal.
    
    Displays full signal details including KI evaluation and Risk Engine results.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
    except (Signal.DoesNotExist, ValueError):
        # Signal not found - redirect to dashboard
        return redirect('signal_dashboard')
    
    context = {
        'signal': signal,
    }
    
    return render(request, 'trading/signal_detail.html', context)


@login_required
@require_http_methods(['POST'])
def execute_live_trade(request, signal_id):
    """
    Execute a live trade for a signal.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        
        if not signal.can_execute_live:
            return JsonResponse({
                'success': False,
                'error': 'Live Trade nicht erlaubt basierend auf Risk Engine Status.'
            }, status=400)
        
        # Create the trade
        trade = Trade.objects.create(
            signal=signal,
            trade_type='LIVE',
            entry_price=signal.trigger_price,
            stop_loss=signal.gpt_corrected_sl or signal.stop_loss,
            take_profit=signal.gpt_corrected_tp or signal.take_profit,
            position_size=signal.gpt_corrected_size or signal.position_size,
        )
        
        # Update signal status
        signal.status = 'EXECUTED'
        signal.executed_at = timezone.now()
        signal.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Live Trade erfolgreich ausgeführt!',
            'trade_id': str(trade.id)
        })
        
    except Signal.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Signal nicht gefunden.'
        }, status=404)


@login_required
@require_http_methods(['POST'])
def execute_shadow_trade(request, signal_id):
    """
    Execute a shadow trade for a signal.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        
        # Create the shadow trade
        trade = Trade.objects.create(
            signal=signal,
            trade_type='SHADOW',
            entry_price=signal.trigger_price,
            stop_loss=signal.gpt_corrected_sl or signal.stop_loss,
            take_profit=signal.gpt_corrected_tp or signal.take_profit,
            position_size=signal.gpt_corrected_size or signal.position_size,
        )
        
        # Update signal status
        signal.status = 'SHADOW'
        signal.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Shadow Trade erfolgreich gestartet!',
            'trade_id': str(trade.id)
        })
        
    except Signal.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Signal nicht gefunden.'
        }, status=404)


@login_required
@require_http_methods(['POST'])
def reject_signal(request, signal_id):
    """
    Reject/dismiss a signal.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        signal.status = 'REJECTED'
        signal.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Signal verworfen.'
        })
        
    except Signal.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Signal nicht gefunden.'
        }, status=404)


@login_required
def trade_history(request):
    """
    Trade history view - Shows executed and shadow trades with pagination.
    """
    trade_list = Trade.objects.select_related('signal').all()
    
    # Paginate results
    paginator = Paginator(trade_list, 25)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'trades': page_obj,
        'page_obj': page_obj,
    }
    
    return render(request, 'trading/trade_history.html', context)


# API Endpoints for HTMX/AJAX integration

@login_required
def api_signals(request):
    """
    GET /api/signals - Return list of active signals as JSON.
    """
    signals = list(Signal.objects.filter(status='ACTIVE').values())
    return JsonResponse({'signals': signals})


@login_required
def api_signals_since(request, since):
    """
    GET /api/signals/since/{timestamp} - Return new signals created after the given timestamp.
    
    Args:
        since: ISO 8601 timestamp string (e.g., '2025-01-01T12:00:00Z')
    
    Response:
        {
            "now": "2025-01-01T12:05:00Z",  # Current server time
            "count": 2,                      # Number of new signals
            "signals": [...]                 # List of new signals
        }
    """
    from django.utils.dateparse import parse_datetime
    
    # Parse the since timestamp
    since_dt = parse_datetime(since)
    if since_dt is None:
        return JsonResponse({
            'error': 'Invalid timestamp format. Use ISO 8601 format (e.g., 2025-01-01T12:00:00Z).'
        }, status=400)
    
    # Ensure the datetime is timezone-aware
    if since_dt.tzinfo is None:
        since_dt = timezone.make_aware(since_dt, timezone.utc)
    
    # Get current server time
    now = timezone.now()
    
    # Query for signals created after the since timestamp
    new_signals = Signal.objects.filter(
        created_at__gt=since_dt,
        status='ACTIVE'
    ).order_by('-created_at')
    
    # Serialize signals
    signals_data = []
    for signal in new_signals:
        signals_data.append({
            'id': str(signal.id),
            'setup_type': signal.setup_type,
            'setup_type_display': signal.get_setup_type_display(),
            'session_phase': signal.session_phase,
            'session_phase_display': signal.get_session_phase_display(),
            'instrument': signal.instrument,
            'direction': signal.direction,
            'trigger_price': str(signal.trigger_price) if signal.trigger_price else None,
            'range_high': str(signal.range_high) if signal.range_high else None,
            'range_low': str(signal.range_low) if signal.range_low else None,
            'stop_loss': str(signal.stop_loss) if signal.stop_loss else None,
            'take_profit': str(signal.take_profit) if signal.take_profit else None,
            'position_size': str(signal.position_size) if signal.position_size else None,
            'gpt_confidence': str(signal.gpt_confidence),
            'risk_status': signal.risk_status,
            'status': signal.status,
            'created_at': signal.created_at.isoformat(),
        })
    
    return JsonResponse({
        'now': now.isoformat(),
        'count': len(signals_data),
        'signals': signals_data,
    })


@login_required
def api_signal_detail(request, signal_id):
    """
    GET /api/trade/{id} - Return signal details as JSON.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        data = {
            'id': str(signal.id),
            'setup_type': signal.setup_type,
            'session_phase': signal.session_phase,
            'direction': signal.direction,
            'trigger_price': str(signal.trigger_price),
            'range_high': str(signal.range_high),
            'range_low': str(signal.range_low),
            'stop_loss': str(signal.stop_loss),
            'take_profit': str(signal.take_profit),
            'position_size': str(signal.position_size),
            'ki_reasoning': signal.ki_reasoning,
            'gpt_confidence': str(signal.gpt_confidence),
            'gpt_reasoning': signal.gpt_reasoning,
            'risk_status': signal.risk_status,
            'risk_reasoning': signal.risk_reasoning,
            'status': signal.status,
            'can_execute_live': signal.can_execute_live,
        }
        return JsonResponse(data)
    except Signal.DoesNotExist:
        return JsonResponse({'error': 'Signal nicht gefunden.'}, status=404)


@login_required
def api_account_state(request):
    """
    GET /api/account-state - Return current account state (balance, margin) from IG Broker.
    
    Returns JSON with account information including:
    - balance: Current account balance
    - available: Available funds for trading
    - equity: Total equity including open positions
    - margin_used: Margin currently in use
    - margin_available: Available margin
    - unrealized_pnl: Unrealized profit/loss
    - currency: Account currency
    - account_name: Account name
    - account_id: Account ID
    - timestamp: When the data was fetched
    - connected: Whether the broker is connected
    """
    try:
        # Create and connect to broker
        broker = create_ig_broker_service()
        broker.connect()
        
        try:
            # Get account state
            account_state = broker.get_account_state()
            
            return JsonResponse({
                'success': True,
                'data': {
                    'account_id': account_state.account_id,
                    'account_name': account_state.account_name,
                    'balance': str(account_state.balance),
                    'available': str(account_state.available),
                    'equity': str(account_state.equity),
                    'margin_used': str(account_state.margin_used),
                    'margin_available': str(account_state.margin_available),
                    'unrealized_pnl': str(account_state.unrealized_pnl),
                    'currency': account_state.currency,
                    'timestamp': account_state.timestamp.isoformat() if account_state.timestamp else None,
                },
                'connected': True,
            })
        finally:
            # Always disconnect
            broker.disconnect()
            
    except ImproperlyConfigured as e:
        logger.warning(f"IG Broker not configured: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Broker nicht konfiguriert. Bitte IG Broker im Admin-Bereich konfigurieren.',
            'connected': False,
        }, status=503)
    except AuthenticationError as e:
        logger.error(f"IG Broker authentication failed: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Broker-Authentifizierung fehlgeschlagen.',
            'connected': False,
        }, status=401)
    except (BrokerError, ConnectionError) as e:
        logger.error(f"IG Broker error: {e}")
        return JsonResponse({
            'success': False,
            'error': f'Broker-Fehler: {str(e)}',
            'connected': False,
        }, status=503)
    except Exception as e:
        logger.error(f"Unexpected error fetching account state: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Ein unerwarteter Fehler ist aufgetreten.',
            'connected': False,
        }, status=500)


@login_required
def api_worker_status(request):
    """
    GET /fiona/api/worker/status/ - Return current worker status.
    
    Returns JSON with worker status information including:
    - worker_status: ONLINE or OFFLINE (based on last_run_at threshold)
    - last_run_at: Timestamp of last worker loop
    - phase: Current session phase
    - epic: Current instrument being monitored
    - price_info: Bid/Ask/Spread
    - setup_count: Number of setups found in last run
    - diagnostic_message: Human-readable status message
    - diagnostic_criteria: List of criteria with pass/fail status
    - worker_interval: Expected worker loop interval
    - seconds_until_next_run: Countdown to next worker run
    """
    try:
        # Get the current worker status
        status = WorkerStatus.get_current()
        
        if status is None:
            return JsonResponse({
                'success': True,
                'worker_status': 'NO_DATA',
                'status_message': 'Noch keine Worker-Statusdaten vorhanden',
                'data': None,
            })
        
        # Determine if worker is ONLINE or OFFLINE
        # ONLINE if last heartbeat is within 2 * worker_interval
        now = timezone.now()
        threshold_seconds = status.worker_interval * 2
        time_since_last_run = (now - status.last_run_at).total_seconds()
        
        if time_since_last_run <= threshold_seconds:
            worker_status = 'ONLINE'
            status_message = 'Worker ist aktiv'
        else:
            worker_status = 'OFFLINE'
            status_message = f'Worker ist seit {int(time_since_last_run)}s inaktiv'
        
        # Calculate seconds until next run
        seconds_until_next_run = max(0, status.worker_interval - int(time_since_last_run))
        
        # Build response data
        data = {
            'last_run_at': status.last_run_at.isoformat(),
            'phase': status.phase,
            'epic': status.epic,
            'price_info': {
                'bid': str(status.bid_price) if status.bid_price else None,
                'ask': str(status.ask_price) if status.ask_price else None,
                'spread': str(status.spread) if status.spread else None,
            },
            'setup_count': status.setup_count,
            'diagnostic_message': status.diagnostic_message,
            'diagnostic_criteria': status.diagnostic_criteria or [],
            'worker_interval': status.worker_interval,
            'seconds_since_last_run': int(time_since_last_run),
            'seconds_until_next_run': seconds_until_next_run,
        }
        
        return JsonResponse({
            'success': True,
            'worker_status': worker_status,
            'status_message': status_message,
            'data': data,
        })
        
    except Exception as e:
        logger.error(f"Error fetching worker status: {e}")
        return JsonResponse({
            'success': False,
            'worker_status': 'ERROR',
            'status_message': f'Fehler: {str(e)}',
            'data': None,
        }, status=500)


@login_required
def api_breakout_range_diagnostics(request):
    """
    GET /api/debug/breakout-range/ - Return breakout range diagnostic data.
    
    Query parameters:
        epic: Market identifier (optional, defaults to CC.D.CL.UNC.IP)
        range_type: Type of range to diagnose (optional, defaults to 'asia')
                    Values: 'asia' or 'pre_us'
    
    Returns JSON with:
        - Range type and period
        - Range high/low/height
        - Current price position relative to range
        - Breakout status
        - Configuration parameters
        - Diagnostic messages
    """
    from datetime import datetime
    from core.services.strategy import (
        BreakoutRangeDiagnosticService,
        StrategyConfig,
        BaseMarketStateProvider,
        SessionPhase,
        Candle,
    )
    
    # Get query parameters
    epic = request.GET.get('epic', 'CC.D.CL.UNC.IP')
    range_type = request.GET.get('range_type', 'asia')
    
    try:
        # Get current worker status for price and phase info
        status = WorkerStatus.get_current()
        
        if status is None:
            return JsonResponse({
                'success': False,
                'error': 'Keine Worker-Daten verfügbar',
                'message': 'Der Worker ist noch nicht aktiv oder hat noch keine Daten gesammelt.',
                'data': None,
            })
        
        # Create a dummy market state provider using worker status data
        # In production, this would use the real MarketStateProvider from the worker
        class WorkerStatusMarketStateProvider(BaseMarketStateProvider):
            """Minimal provider using WorkerStatus data."""
            
            def __init__(self, worker_status):
                self._status = worker_status
                self._phase = SessionPhase(worker_status.phase) if worker_status.phase else SessionPhase.OTHER
            
            def get_phase(self, ts):
                return self._phase
            
            def get_recent_candles(self, epic, timeframe, limit):
                # Return empty list - we don't have candle data in WorkerStatus
                return []
            
            def get_asia_range(self, epic):
                # Note: In production, this would come from the real MarketStateProvider
                # For now, return None to indicate data is not available
                return None
            
            def get_pre_us_range(self, epic):
                # Note: In production, this would come from the real MarketStateProvider
                return None
            
            def get_atr(self, epic, timeframe, period):
                return None
        
        # Create diagnostic service
        provider = WorkerStatusMarketStateProvider(status)
        config = StrategyConfig()
        service = BreakoutRangeDiagnosticService(provider, config)
        
        # Get current price from worker status
        current_price = None
        if status.bid_price and status.ask_price:
            # Use mid price
            current_price = float((status.bid_price + status.ask_price) / 2)
        elif status.bid_price:
            current_price = float(status.bid_price)
        
        # Get diagnostics based on range type
        ts = timezone.now()
        if range_type == 'pre_us':
            diagnostics = service.get_pre_us_range_diagnostics(epic, ts, current_price)
        else:
            diagnostics = service.get_asia_range_diagnostics(epic, ts, current_price)
        
        return JsonResponse({
            'success': True,
            'epic': epic,
            'range_type': range_type,
            'data': diagnostics.to_dict(),
            'worker_status': {
                'phase': status.phase,
                'last_run_at': status.last_run_at.isoformat() if status.last_run_at else None,
            },
        })
        
    except Exception as e:
        logger.error(f"Error fetching breakout range diagnostics: {e}")
        return JsonResponse({
            'success': False,
            'error': f'Fehler beim Abrufen der Range-Diagnose: {str(e)}',
            'data': None,
        }, status=500)
