from django.shortcuts import render, get_object_or_404, redirect
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.contrib.auth.decorators import login_required
from django.core.paginator import Paginator
from django.utils import timezone

from .models import Signal, Trade


@login_required
def signal_dashboard(request):
    """
    Signal Dashboard - Main view showing all active trading signals.
    
    Displays signals from the database that are generated by the real
    Strategy Engine, KI Layer, and Risk Engine services.
    """
    signals = Signal.objects.filter(status='ACTIVE')
    active_count = signals.count()
    
    context = {
        'signals': signals,
        'active_count': active_count,
    }
    
    return render(request, 'trading/signal_dashboard.html', context)


@login_required
def signal_detail(request, signal_id):
    """
    Trade Detail Panel - Detailed view of a specific signal.
    
    Displays full signal details including KI evaluation and Risk Engine results.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
    except (Signal.DoesNotExist, ValueError):
        # Signal not found - redirect to dashboard
        return redirect('signal_dashboard')
    
    context = {
        'signal': signal,
    }
    
    return render(request, 'trading/signal_detail.html', context)


@login_required
@require_http_methods(['POST'])
def execute_live_trade(request, signal_id):
    """
    Execute a live trade for a signal.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        
        if not signal.can_execute_live:
            return JsonResponse({
                'success': False,
                'error': 'Live Trade nicht erlaubt basierend auf Risk Engine Status.'
            }, status=400)
        
        # Create the trade
        trade = Trade.objects.create(
            signal=signal,
            trade_type='LIVE',
            entry_price=signal.trigger_price,
            stop_loss=signal.gpt_corrected_sl or signal.stop_loss,
            take_profit=signal.gpt_corrected_tp or signal.take_profit,
            position_size=signal.gpt_corrected_size or signal.position_size,
        )
        
        # Update signal status
        signal.status = 'EXECUTED'
        signal.executed_at = timezone.now()
        signal.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Live Trade erfolgreich ausgef√ºhrt!',
            'trade_id': str(trade.id)
        })
        
    except Signal.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Signal nicht gefunden.'
        }, status=404)


@login_required
@require_http_methods(['POST'])
def execute_shadow_trade(request, signal_id):
    """
    Execute a shadow trade for a signal.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        
        # Create the shadow trade
        trade = Trade.objects.create(
            signal=signal,
            trade_type='SHADOW',
            entry_price=signal.trigger_price,
            stop_loss=signal.gpt_corrected_sl or signal.stop_loss,
            take_profit=signal.gpt_corrected_tp or signal.take_profit,
            position_size=signal.gpt_corrected_size or signal.position_size,
        )
        
        # Update signal status
        signal.status = 'SHADOW'
        signal.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Shadow Trade erfolgreich gestartet!',
            'trade_id': str(trade.id)
        })
        
    except Signal.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Signal nicht gefunden.'
        }, status=404)


@login_required
@require_http_methods(['POST'])
def reject_signal(request, signal_id):
    """
    Reject/dismiss a signal.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        signal.status = 'REJECTED'
        signal.save()
        
        return JsonResponse({
            'success': True,
            'message': 'Signal verworfen.'
        })
        
    except Signal.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Signal nicht gefunden.'
        }, status=404)


@login_required
def trade_history(request):
    """
    Trade history view - Shows executed and shadow trades with pagination.
    """
    trade_list = Trade.objects.select_related('signal').all()
    
    # Paginate results
    paginator = Paginator(trade_list, 25)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'trades': page_obj,
        'page_obj': page_obj,
    }
    
    return render(request, 'trading/trade_history.html', context)


# API Endpoints for HTMX/AJAX integration

@login_required
def api_signals(request):
    """
    GET /api/signals - Return list of active signals as JSON.
    """
    signals = list(Signal.objects.filter(status='ACTIVE').values())
    return JsonResponse({'signals': signals})


@login_required
def api_signal_detail(request, signal_id):
    """
    GET /api/trade/{id} - Return signal details as JSON.
    """
    try:
        signal = Signal.objects.get(id=signal_id)
        data = {
            'id': str(signal.id),
            'setup_type': signal.setup_type,
            'session_phase': signal.session_phase,
            'direction': signal.direction,
            'trigger_price': str(signal.trigger_price),
            'range_high': str(signal.range_high),
            'range_low': str(signal.range_low),
            'stop_loss': str(signal.stop_loss),
            'take_profit': str(signal.take_profit),
            'position_size': str(signal.position_size),
            'ki_reasoning': signal.ki_reasoning,
            'gpt_confidence': str(signal.gpt_confidence),
            'gpt_reasoning': signal.gpt_reasoning,
            'risk_status': signal.risk_status,
            'risk_reasoning': signal.risk_reasoning,
            'status': signal.status,
            'can_execute_live': signal.can_execute_live,
        }
        return JsonResponse(data)
    except Signal.DoesNotExist:
        return JsonResponse({'error': 'Signal nicht gefunden.'}, status=404)
